// SPDX-License-Identifier: AGPL-3.0-or-later
/*
 * Copyright (C) 2024 Squangleding Corporation
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Full license text is available at:
 * https://github.com/yeet-protocol/contracts/blob/main/LICENSE.md
 */
pragma solidity ^0.8.19;

import {IEntropyConsumer} from "@pythnetwork/entropy-sdk-solidity/IEntropyConsumer.sol";
import {IEntropy} from "@pythnetwork/entropy-sdk-solidity/IEntropy.sol";
import "@openzeppelin/contracts/access/Ownable2Step.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/// @title Yeetback contract, a contract that allows users to participate in a yeetback and win some BERA from the current pot
/// @notice Every round have a yeetback pot, 10 winners are selected from the yeets in the round and they get 10% each of the yeetback pot
/// @dev The contract uses the Pyth Network Entropy SDK to generate random numbers
contract Yeetback is Ownable2Step, IEntropyConsumer, ReentrancyGuard {
    /// @dev The entropy contract address
    IEntropy private entropy;
    /// @dev The address of the entropy provider
    address private entropyProvider;

    //Mapping
    mapping(uint256 => mapping(address => uint16)) public amountOfWins;
    mapping(uint256 => mapping(address => bool)) public claimed;
    mapping(uint256 => uint256) public amountToWinners;

    /// @notice Mapping of the pot value for each round
    /// @dev round => pot value
    mapping(uint256 => uint256) public potForRound;
    /// @notice Mapping of the yeets in each round
    /// @dev round => yeets
    mapping(uint256 => address[]) public yeetsInRound;
    /// @notice Mapping of the sequence number to the round
    /// @dev sequence number => round
    mapping(uint256 => uint256) public sequenceToRound;
    /// @notice Mapping of the sequence number to VRF randomness callback status
    /// @dev sequence number => bool
    mapping(uint256 => bool) public finishedSequenceNumbers;

    event RandomNumberRequested(uint256 indexed sequenceNumber);
    event YeetbackAdded(uint256 indexed round, uint256 amount);
    event YeetbackWinner(uint256 indexed round, address indexed winner, uint256 amount, uint256 winningYeetIndex);
    event Claimed(uint256 indexed round, address indexed user, uint256 amount);

    constructor(address _entropy, address _entropyProvider) Ownable(msg.sender) {
        require(_entropy != address(0), "Yeetback: Invalid entropy address");
        require(_entropyProvider != address(0), "Yeetback: Invalid entropy provider address");
        entropy = IEntropy(_entropy);
        entropyProvider = _entropyProvider;
    }

    /// @notice Drafts the winners for the round using the random number generated by the entropy contract
    /// @dev The random number is used to select the winners from the yeets in the round
    /// @dev We don't want to get 10 random numbers from the entropy contract because it's expensive, so we use a single random number and seed it with some entropy
    /// @dev We hash the smaller number so that its distribution is more uniform
    function draftWinners(uint256 randomNumber, uint256 round) private {
        uint256 potValue = potForRound[round];
        uint256 nrOfYeets = yeetsInRound[round].length;
        uint256 nrOfWinners = 10;

        uint256 winnings = potValue / nrOfWinners;
        amountToWinners[round] = winnings;

        for (uint256 i; i < nrOfWinners; i++) {
            uint256 randomDataNumber = uint256(keccak256(abi.encodePacked(randomNumber, i)));
            uint256 winningYeetIndex = randomDataNumber % nrOfYeets; // index of the winning yeet
            address winnerAddress = yeetsInRound[round][winningYeetIndex];

            // Update amountToWinners and amountOfWins
            amountOfWins[round][winnerAddress] += 1;

            emit YeetbackWinner(round, winnerAddress, winnings, winningYeetIndex);
        }
    }

    /// @notice Adds a user to the yeets in the round, this is done from the YEET contract and will be used to select the winners
    /// @param round The round number
    /// @param user The user address
    function addYeetsInRound(uint256 round, address user) public onlyOwner {
        require(user != address(0), "Yeetback: Invalid user address");
        require(round != 0, "Invalid round");
        yeetsInRound[round].push(user);
    }

    function getYeetsInRound(uint256 round) public view returns (address[] memory) {
        return yeetsInRound[round];
    }

    /// @notice Adds a yeetback to the pot for the round, this is done after the YEET contract has finished a round
    /// @param userRandomNumber The user random number
    /// @param round The round number
    /// @param amount The amount to add to the pot
    function addYeetback(bytes32 userRandomNumber, uint256 round, uint256 amount) public payable onlyOwner {
        require(userRandomNumber != bytes32(0), "Invalid number");
        require(round != 0, "Invalid round");
        require(amount != 0, "Invalid amount");
        potForRound[round] = amount;

        uint256 fee = getEntropyFee();
        uint64 sequenceNumber = entropy.requestWithCallback{value: fee}(entropyProvider, userRandomNumber);
        sequenceToRound[sequenceNumber] = round;
        emit RandomNumberRequested(sequenceNumber);
        emit YeetbackAdded(round, amount);
    }

    /// @notice Claims the winnings for the user
    /// @param round The round number
    function claim(uint256 round) public nonReentrant {
        require(round != 0, "Yeetback: Invalid round");
        uint16 nrOfWins = amountOfWins[round][msg.sender];
        require(nrOfWins != 0, "Yeetback: No winnings to claim");
        require(!claimed[round][msg.sender], "Yeetback: Already claimed");

        claimed[round][msg.sender] = true;
        uint256 amount = amountToWinners[round] * nrOfWins;
        (bool success,) = payable(msg.sender).call{value: amount}("");
        require(success, "Transfer failed.");
        emit Claimed(round, msg.sender, amount);
    }

    /// @notice Returns the amount that the user can claim
    /// @param round The round number
    /// @param user The user address
    /// @return The amount that the user can claim
    function claimable(uint256 round, address user) public view returns (uint256) {
        uint16 nrOfWins = amountOfWins[round][user];
        uint256 amount = amountToWinners[round] * nrOfWins;
        bool haveClaimed = claimed[round][user];
        if (haveClaimed || amount == 0) {
            return 0;
        }

        return amount;
    }

    /// @notice Returns the entropy fee, used in the dApp to show the user how much they need to pay
    function getEntropyFee() public view returns (uint128) {
        return entropy.getFee(entropyProvider);
    }

    /// @dev This needs to be less then 500K in gas, otherwise the transaction will fail.
    // This method is required by the IEntropyConsumer interface.
    // It is called by the entropy contract when a random number is generated.
    function entropyCallback(
        uint64 sequenceNumber,
        // If your app uses multiple providers, you can use this argument
        // to distinguish which one is calling the app back. This app only
        // uses one provider so this argument is not used.
        address,
        bytes32 randomData
    ) internal override {
        require(!finishedSequenceNumbers[sequenceNumber], "Yeetback: Already processed");
        finishedSequenceNumbers[sequenceNumber] = true;
        draftWinners(uint256(randomData), sequenceToRound[sequenceNumber]);
    }

    // This method is required by the IEntropyConsumer interface.
    // It returns the address of the entropy contract which will call the callback.
    function getEntropy() internal view override returns (address) {
        return address(entropy);
    }
}
